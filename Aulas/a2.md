# Aula 2 (6ago)

Revisão, implementação do que tinha ficado como exercício na aula anterior.
Abaixo está a implementação feita em aula, com algumas modificações tentando deixar mais claro.
Executando, um dos testes falha.
Consegue encontrar o bug e corrigir?

```c
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

// implementação do exercício em t1, l225b

/******************************************
Enquanto não vem uma descrição mais completa, implemente uma função que realiza a substituição de uma substring em uma string por outra string. A função deve ter a assinatura abaixo:

   bool strsubst(int n, char s[n], int pos, int tam, char *outra);

O vetor s, de tamanho n contém uma string (terminada por '\0'). A função deve substituir a substring de tamanho tam que inicia pelo caractere que está na posição pos de s pela string que inicia em outra. Se a substituição for bem sucedida, a função deve retornar true. Caso contrário, deve retornar false. Motivos para isso:

    s não sem tamanho suficiente para conter o resultado
    pos/tam não constituem uma substring de s

A string em s pode ser vazia. A substring pode ser vazia. A string em outra pode ser vazia.

Suponha que s tenha tamanho 12, e conteúdo "abacaxi".

    A chamada strsubst(12, s, 5, 2, "te") deve substituir o valor em s por "abacate".
    A chamada strsubst(12, s, 7, 0, ".") deve substituir o valor em s por "abacaxi.".
    A chamada strsubst(12, s, 3, 4, "") deve substituir o valor em s por "aba".
    A chamada strsubst(12, s, 0, 0, "Um ") deve substituir o valor em s por "Um abacaxi".
    A chamada strsubst(12, s, 0, 0, "Umas ") deve não alterar o valor em s e retornar false.
**********************************************/ 

bool strsubst(int tam_vet, char vet[tam_vet], int pos_sub, int tam_sub, char *insercao)
{
  /// testa se os argumentos estão OK e se é possível colocar o resultado no
  ///   vetor recebido -- retorna false se não der
  if (pos_sub < 0 || tam_sub < 0) return false; // substring mal formada
  int tam_str = strlen(vet);
  if (tam_str >= tam_vet - 1) return false; // a string original ultrapassa o vetor
  if (pos_sub > tam_str) return false; // a substring inicia depois da string
  if (pos_sub + tam_sub > tam_str) return false; // ... ou termina (poderia eliminar o teste anterior)
  int tam_insercao = strlen(insercao);
  // acho que fica mais fácil tendo o tamanho de todos (parte fixa no início, substring
  //   removida, substring substituta, parte final que permanece)
  int tam_fixa = pos_sub;
  int tam_final = tam_str - tam_fixa - tam_sub;
  int tam_resultado = tam_fixa + tam_insercao + tam_final;
  if (tam_resultado > tam_vet - 1) return false; // se o resultado não couber
 
  /// copia a parte final para o local onde ela deve ficar no resultado
  int de_onde = pos_sub + tam_sub;
  int pra_onde = pos_sub + tam_insercao;
  int quantos = tam_final;

  // só copia se for necessário
  if (quantos > 0 && pra_onde != de_onde) {
    // se a cópia é para uma posição anterior, copia o byte da esquerda antes;
    // se for para uma posição posterior, copia o byte da direita antes
    if (pra_onde < de_onde) {
      int origem = de_onde;
      int destino = pra_onde;
      for (int i = 0; i < quantos; i++) {
        vet[destino] = vet[origem];
        origem++;
        destino++;
      }
    } else {
      int origem = de_onde + quantos - 1;
      int destino = pra_onde + quantos - 1;
      for (int i = 0; i < quantos; i++) {
        vet[destino] = vet[origem];
        origem--;
        destino--;
      }
    }
  }

  /// copia a string a inserir para o local pedido na string original
  int origem = 0;
  int destino = pos_sub;
  for (int i = 0; i < tam_insercao; i++) {
    vet[destino] = insercao[origem];
    origem++;
    destino++;
  }

  return true;
}

// se a e b forem iguais, o teste deu certo. imprime.
void testa(char *a, char *b)
{
  if (strcmp(a, b) != 0) {
    printf("teste errado '%s' != '%s'\n", a, b);
  } else {
    printf("teste certo\n");
  }
}

int main()
{
  char s[12];
  char g[12] = "abacaxi";

  // faz os testes exemplificados na descrição
  // strsubst(12, s, 5, 2, "te") deve substituir o valor em s por "abacate".
  strcpy(s, g);
  strsubst(12, s, 5, 2, "te");
  testa(s, "abacate");
  // strsubst(12, s, 7, 0, ".") deve substituir o valor em s por "abacaxi.".
  strcpy(s, g);
  strsubst(12, s, 7, 0, ".");
  testa(s, "abacaxi.");
  // strsubst(12, s, 3, 4, "") deve substituir o valor em s por "aba".
  strcpy(s, g);
  strsubst(12, s, 3, 4, "");
  testa(s, "aba");
  // strsubst(12, s, 0, 0, "Um ") deve substituir o valor em s por "Um abacaxi".
  strcpy(s, g);
  strsubst(12, s, 0, 0, "Um ");
  testa(s, "Um abacaxi");
  // strsubst(12, s, 0, 0, "Umas ") deve não alterar o valor em s e retornar false.
  strcpy(s, g);
  if (strsubst(12, s, 0, 0, "Umas ")) {
    printf("Erro, a última chamada deveria ter dado false\n");
  }
  testa(s, "abacaxi");
}
```
